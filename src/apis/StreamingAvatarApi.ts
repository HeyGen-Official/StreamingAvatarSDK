/* tslint:disable */
/* eslint-disable */
/**
 * Streaming Avatar SDK
 * Heygen Streaming Avatar
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@heygen.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  IceRequest,
  IceResponse,
  NewSessionData,
  NewSessionIceServers2,
  NewSessionRequest,
  NewSessionResponse,
  Sdp,
  StartSessionRequest,
  StartSessionResponse,
  StopSessionRequest,
  StopSessionResponse,
  TaskRequest,
  TaskResponse,
} from '../models/index';
import {
    IceRequestFromJSON,
    IceRequestToJSON,
    IceResponseFromJSON,
    IceResponseToJSON,
    NewSessionRequestFromJSON,
    NewSessionRequestToJSON,
    NewSessionResponseFromJSON,
    NewSessionResponseToJSON,
    StartSessionRequestFromJSON,
    StartSessionRequestToJSON,
    StartSessionResponseFromJSON,
    StartSessionResponseToJSON,
    StopSessionRequestFromJSON,
    StopSessionRequestToJSON,
    StopSessionResponseFromJSON,
    StopSessionResponseToJSON,
    TaskRequestFromJSON,
    TaskRequestToJSON,
    TaskResponseFromJSON,
    TaskResponseToJSON,
} from '../models/index';

export interface CreateStreamingAvatarRequest {
    newSessionRequest: NewSessionRequest;
}

export interface SpeakRequest {
    taskRequest: TaskRequest;
}

export interface StartStreamingAvatarRequest {
    startSessionRequest: StartSessionRequest;
}

export interface StopSessionOperationRequest {
    stopSessionRequest: StopSessionRequest;
}

export interface SubmitICECandidateRequest {
    iceRequest: IceRequest;
}

/**
 * 
 */
export class StreamingAvatarApi extends runtime.BaseAPI {

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Opens and returns a new streaming avatar session
     */
    async createStreamingAvatarRaw(requestParameters: CreateStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewSessionResponse>> {
        if (requestParameters['newSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'newSessionRequest',
                'Required parameter "newSessionRequest" was null or undefined when calling createStreamingAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/streaming.new`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewSessionRequestToJSON(requestParameters['newSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewSessionResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Opens and returns a new streaming avatar session
     */
    async createStreamingAvatar(requestParameters: CreateStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewSessionResponse> {
        const response = await this.createStreamingAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pass text to be repeated by avatar
     */
    async speakRaw(requestParameters: SpeakRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskResponse>> {
        if (requestParameters['taskRequest'] == null) {
            throw new runtime.RequiredError(
                'taskRequest',
                'Required parameter "taskRequest" was null or undefined when calling speak().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/streaming.task`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TaskRequestToJSON(requestParameters['taskRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskResponseFromJSON(jsonValue));
    }

    /**
     * Pass text to be repeated by avatar
     */
    async speak(requestParameters: SpeakRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskResponse> {
        const response = await this.speakRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Starts the streaming avatar session. Must be called after creation.
     */
    async startStreamingAvatarRaw(requestParameters: StartStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartSessionResponse>> {
        if (requestParameters['startSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'startSessionRequest',
                'Required parameter "startSessionRequest" was null or undefined when calling startStreamingAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/streaming.start`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StartSessionRequestToJSON(requestParameters['startSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StartSessionResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Starts the streaming avatar session. Must be called after creation.
     */
    async startStreamingAvatar(requestParameters: StartStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartSessionResponse> {
        const response = await this.startStreamingAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops the streaming avatar session. This endpoint has been exposed to support advanced applications. To ensure the RTC session is correctly closed, please use stopAvatar instead.
     */
    async stopSessionRaw(requestParameters: StopSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopSessionResponse>> {
        if (requestParameters['stopSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'stopSessionRequest',
                'Required parameter "stopSessionRequest" was null or undefined when calling stopSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/streaming.stop`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StopSessionRequestToJSON(requestParameters['stopSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StopSessionResponseFromJSON(jsonValue));
    }

    /**
     * Stops the streaming avatar session. This endpoint has been exposed to support advanced applications. To ensure the RTC session is correctly closed, please use stopAvatar instead.
     */
    async stopSession(requestParameters: StopSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopSessionResponse> {
        const response = await this.stopSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Submit the ICE candidate. Dependent on active session.
     */
    async submitICECandidateRaw(requestParameters: SubmitICECandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IceResponse>> {
        if (requestParameters['iceRequest'] == null) {
            throw new runtime.RequiredError(
                'iceRequest',
                'Required parameter "iceRequest" was null or undefined when calling submitICECandidate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/streaming.ice`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IceRequestToJSON(requestParameters['iceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IceResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Submit the ICE candidate. Dependent on active session.
     */
    async submitICECandidate(requestParameters: SubmitICECandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IceResponse> {
        const response = await this.submitICECandidateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call both terminates the streaming avatar session and closes the RTC connection
     */
    async stopAvatar(requestParameters: StopSessionOperationRequest, debugStream?: (string)=>void, initOverrides?: RequestInit | runtime.InitOverrideFunction){
        if(this.peerConnection){
            this.peerConnection.close();
        }   
       
        const debug = new Debug(debugStream);
        await this.stopSession(requestParameters.stopSessionRequest.sessionId ? requestParameters : {
            stopSessionRequest: {sessionId: this.sessionId ?? ""}
        } , initOverrides).catch((error)=>{
            debug.print(JSON.stringify(error));
        });
        debug.print("Stopped session successfully.")
    }

    /**
     * This call creates and starts a new streaming avatar session
     */
    async createStartAvatar(requestParameters: CreateStreamingAvatarRequest, handleMediaStream?: (stream: MediaStream) => void, debugStream?: (string)=>void, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewSessionData> {
        const convertToRTCIceServer = (iceServers: NewSessionIceServers2[]) => {
            const rtcs: RTCIceServer[] = [];
            iceServers.forEach(server => {
                const rtc = {
                    urls: server.urls,
                    username: server.username,
                    credential: server.credential
                }
                rtcs.push(rtc);
            });
            return rtcs;
        }

        const convertToRTCSessionDescription = (serverSdp : Sdp) => {
            return new RTCSessionDescription({sdp: serverSdp.sdp, type: serverSdp.type as RTCSdpType})
        }


        const onMessage = (event) => {
            const message = event.data;
            console.log('STREAMING AVATAR: Received message:', message);
        }
        
        const debug = new Debug(debugStream);

        try{
            debug.print("Creating a new session...");

            const {data} = await this.createStreamingAvatar(requestParameters, initOverrides);
            const { sdp: serverSdp, iceServers2: iceServers } = data;
            this.sessionId = data.sessionId;

            this.peerConnection = new RTCPeerConnection({iceServers: convertToRTCIceServer(iceServers)});

            this.peerConnection.ontrack = (event) => {
                
                if ( event.track.kind === 'audio' || event.track.kind == 'video'){
                    console.log("STREAMING AVATAR: Received the track", event.track);
                    
                    if(handleMediaStream){
                        handleMediaStream(event.streams[0]);
                    }
                    this._mediaStream = event.streams[0];

                }
            }

            // When receiving a message, display it in the status element
            this.peerConnection.ondatachannel = (event) => {
                const dataChannel = event.channel;
                dataChannel.onmessage = onMessage;
            };

            // Set server's SDP as remote description
            const remoteDescription = new RTCSessionDescription(convertToRTCSessionDescription(serverSdp));
            await this.peerConnection.setRemoteDescription(remoteDescription);

            debug.print("Session creation complete.");

            if(!data){
                console.log("STREAMING AVATAR: Please create session first");
                throw Error("STREAMING AVATAR: Issue with created session");
            }

            debug.print("Starting the session...");
            const localDescription = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(localDescription);

            this.peerConnection.onicecandidate = async ({ candidate }) => {
                console.log('STREAMING AVATAR: Received ICE candidate:', candidate);
                if (candidate) {
                        console.log("STREAMING AVATAR",  {candidate: candidate.candidate, sdpMid: candidate.sdpMid, sdpMLineIndex: candidate.sdpMLineIndex, usernameFragment: candidate.usernameFragment});
                        this.submitICECandidate({iceRequest: {sessionId: this.sessionId, candidate: {candidate: candidate.candidate, sdpMid: candidate.sdpMid, sdpMLineIndex: candidate.sdpMLineIndex, usernameFragment: candidate.usernameFragment}}})
                        .then( async (c) => {
                            // When ICE connection state changes, display the new state
                            this.peerConnection.oniceconnectionstatechange = (_event) => {
                                debugStream(`ICE connection state changed to: ${this.peerConnection.iceConnectionState}`);
                            };  
                        }
                        ).catch(error => {
                            debug.print(JSON.stringify(error));
                        });
                }
            };

            await this.startStreamingAvatar({startSessionRequest: {sdp: localDescription, sessionId: this.sessionId}});

            debug.print("Session started successfully");

            return data;
        } catch (error){
            this.peerConnection.close();
        }
       
    }

    get mediaStream(){
        return this._mediaStream;
    }

}

class Debug {
    private _debug: (text: string) => void;

    constructor(debug?: (text: string) => void){
        this._debug = debug;
    }

    print(text: string) {
        if(!this._debug){
            return;
        }

        this._debug(text);
    }
}
