/* tslint:disable */
/* eslint-disable */
/**
 * Streaming Avatar SDK
 * Heygen Streaming Avatar
 *
 * The version of the OpenAPI document: 1.0.4
 * Contact: api@heygen.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Room, RoomEvent, VideoPresets } from 'livekit-client';
import * as runtime from '../runtime';
import type {
    IceRequest,
    IceResponse,
    InterruptRequest,
    InterruptResponse,
    NewSessionData,
    NewSessionIceServers2,
    NewSessionRequest,
    NewSessionResponse,
    Sdp,
    StartSessionRequest,
    StartSessionResponse,
    StopSessionRequest,
    StopSessionResponse,
    TaskRequest,
    TaskResponse,
} from '../models/index';
import {
    IceRequestFromJSON,
    IceRequestToJSON,
    IceResponseFromJSON,
    IceResponseToJSON,
    InterruptRequestFromJSON,
    InterruptRequestToJSON,
    InterruptResponseFromJSON,
    InterruptResponseToJSON,
    NewSessionRequestFromJSON,
    NewSessionRequestToJSON,
    NewSessionResponseFromJSON,
    NewSessionResponseToJSON,
    StartSessionRequestFromJSON,
    StartSessionRequestToJSON,
    StartSessionResponseFromJSON,
    StartSessionResponseToJSON,
    StopSessionRequestFromJSON,
    StopSessionRequestToJSON,
    StopSessionResponseFromJSON,
    StopSessionResponseToJSON,
    TaskRequestFromJSON,
    TaskRequestToJSON,
    TaskResponseFromJSON,
    TaskResponseToJSON,
} from '../models/index';
import { parseEvent } from '../events/utils';
import { EventMap, EventType } from '../events/events';

export interface CreateStreamingAvatarRequest {
    newSessionRequest: NewSessionRequest;
}

export interface InterruptOperationRequest {
    interruptRequest: InterruptRequest;
}

export interface SpeakRequest {
    taskRequest: TaskRequest;
}

export interface StartStreamingAvatarRequest {
    startSessionRequest: StartSessionRequest;
}

export interface StopSessionOperationRequest {
    stopSessionRequest: StopSessionRequest;
}

export interface SubmitICECandidateRequest {
    iceRequest: IceRequest;
}

/**
 * 
 */
export class StreamingAvatarApi extends runtime.BaseAPI {

    private eventSystem: EventTarget = new EventTarget();
    private listenerMap: Map<EventType, Map<(detailData: any) => any, (ev: CustomEvent) => any>> = new Map();

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Opens and returns a new streaming avatar session
     */
    async createStreamingAvatarRaw(requestParameters: CreateStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewSessionResponse>> {
        if (requestParameters['newSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'newSessionRequest',
                'Required parameter "newSessionRequest" was null or undefined when calling createStreamingAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.new`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewSessionRequestToJSON(requestParameters['newSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewSessionResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Opens and returns a new streaming avatar session
     */
    async createStreamingAvatar(requestParameters: CreateStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewSessionResponse> {
        const response = await this.createStreamingAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Interrupt the current Streaming
     */
    async interruptRaw(requestParameters: InterruptOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InterruptResponse>> {
        if (requestParameters['interruptRequest'] == null) {
            throw new runtime.RequiredError(
                'interruptRequest',
                'Required parameter "interruptRequest" was null or undefined when calling interrupt().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.interrupt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InterruptRequestToJSON(requestParameters['interruptRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InterruptResponseFromJSON(jsonValue));
    }

    /**
     * Interrupt the current Streaming
     */
    async interrupt(requestParameters: InterruptOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InterruptResponse> {
        const response = await this.interruptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pass text to be repeated by avatar
     */
    async speakRaw(requestParameters: SpeakRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskResponse>> {
        if (requestParameters['taskRequest'] == null) {
            throw new runtime.RequiredError(
                'taskRequest',
                'Required parameter "taskRequest" was null or undefined when calling speak().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.task`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TaskRequestToJSON(requestParameters['taskRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskResponseFromJSON(jsonValue));
    }

    /**
     * Pass text to be repeated by avatar
     */
    async speak(requestParameters: SpeakRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskResponse> {
        const response = await this.speakRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Starts the streaming avatar session. Must be called after creation.
     */
    async startStreamingAvatarRaw(requestParameters: StartStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartSessionResponse>> {
        if (requestParameters['startSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'startSessionRequest',
                'Required parameter "startSessionRequest" was null or undefined when calling startStreamingAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.start`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StartSessionRequestToJSON(requestParameters['startSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StartSessionResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Starts the streaming avatar session. Must be called after creation.
     */
    async startStreamingAvatar(requestParameters: StartStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartSessionResponse> {
        const response = await this.startStreamingAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops the streaming avatar session. This endpoint has been exposed to support advanced applications. To ensure the RTC session is correctly closed, please use stopAvatar instead.
     */
    async stopSessionRaw(requestParameters: StopSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopSessionResponse>> {
        if (requestParameters['stopSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'stopSessionRequest',
                'Required parameter "stopSessionRequest" was null or undefined when calling stopSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.stop`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StopSessionRequestToJSON(requestParameters['stopSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StopSessionResponseFromJSON(jsonValue));
    }

    /**
     * Stops the streaming avatar session. This endpoint has been exposed to support advanced applications. To ensure the RTC session is correctly closed, please use stopAvatar instead.
     */
    async stopSession(requestParameters: StopSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopSessionResponse> {
        const response = await this.stopSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Submit the ICE candidate. Dependent on active session.
     */
    async submitICECandidateRaw(requestParameters: SubmitICECandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IceResponse>> {
        if (requestParameters['iceRequest'] == null) {
            throw new runtime.RequiredError(
                'iceRequest',
                'Required parameter "iceRequest" was null or undefined when calling submitICECandidate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.ice`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IceRequestToJSON(requestParameters['iceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IceResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Submit the ICE candidate. Dependent on active session.
     */
    async submitICECandidate(requestParameters: SubmitICECandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IceResponse> {
        const response = await this.submitICECandidateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call both terminates the streaming avatar session and closes the RTC connection
     */
    async stopAvatar(requestParameters: StopSessionOperationRequest, debugStream?: (string) => void, initOverrides?: RequestInit | runtime.InitOverrideFunction) {
        if (this.peerConnection) {
            this.peerConnection.close();
        }

        const debug = new Debug(debugStream);
        await this.stopSession(requestParameters.stopSessionRequest.sessionId ? requestParameters : {
            stopSessionRequest: { sessionId: this.sessionId ?? "" }
        }, initOverrides).catch((error) => {
            debug.print(JSON.stringify(error));
        });
        debug.print("Stopped session successfully.")
    }

    /**
     * This call creates and starts a new streaming avatar session
     */
    async createStartAvatar(requestParameters: CreateStreamingAvatarRequest, debugStream?: (string) => void, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewSessionData> {
        const debug = new Debug(debugStream);

        try {
            debug.print("Creating a new session...");

            const { data } = await this.createStreamingAvatar(requestParameters, initOverrides);
            this.sessionId = data.sessionId;

            const { accessToken, url } = data || {};

            const room = new Room({
                adaptiveStream: true,
                dynacast: true,
                videoCaptureDefaults: {
                    resolution: VideoPresets.h720.resolution,
                },
            });
            room.on(RoomEvent.DataReceived, (roomMessage) => {
                try {
                    const messageString = new TextDecoder().decode(roomMessage as ArrayBuffer);
                    debug.print(`Received event: ${messageString}`);
                    // convert data to JSON
                    const eventMsg = parseEvent(messageString);
                    if (eventMsg != null) {
                        this.eventSystem.dispatchEvent(eventMsg);
                    }
                } catch (e) {
                    debug.print(`STREAMING AVATAR: Received message error: ${roomMessage}`);
                }
            });
            const mediaStream = new MediaStream();
            room.on(RoomEvent.TrackSubscribed, (track, trackPublication) => {
                if (trackPublication.kind === 'video' || trackPublication.kind === 'audio') {
                    trackPublication.track?.mediaStream?.getTracks().forEach((mediaTrack) => {
                        mediaStream.addTrack(mediaTrack);
                    });
                    this._mediaStream = mediaStream;
                }
            });
            room.on(RoomEvent.Disconnected, () => {
                debug.print('STREAMING AVATAR disconnected');
            });

            debug.print("Session creation complete.");

            if (!data) {
                throw Error("STREAMING AVATAR: Issue with created session");
            }

            debug.print("Starting the session...");

            await this.startStreamingAvatar({ startSessionRequest: { sessionId: this.sessionId } });

            // connect to room
            await room.connect(url, accessToken);

            debug.print("Session started successfully");

            return data;
        } catch (error) {
            debug.print('Session start error: ' + error);
        }
    }

    addEventHandler<K extends EventType>(event: K, listener: (data: any) => any) {
        let newListener = (customEv: CustomEvent) => {
            if (customEv.detail.type === event) {
                listener(customEv.detail);
            }
        }

        if (!this.listenerMap.has(event)) {
            this.listenerMap.set(event, new Map());
        }
        this.listenerMap.get(event)!.set(listener, newListener);

        this.eventSystem.addEventListener(event, newListener);
    }

    removeEventHandler<K extends EventType>(event: K, listener: (data: any) => any) {
        const eventListeners = this.listenerMap.get(event);
        if (eventListeners) {
            const newListener = eventListeners.get(listener);
            if (newListener) {
                this.eventSystem.removeEventListener(event, newListener);
                eventListeners.delete(listener);
                if (eventListeners.size === 0) {
                    this.listenerMap.delete(event);
                }
            }
        }
    }

    get mediaStream() {
        return this._mediaStream;
    }

}


class Debug {
    private _debug: (text: string) => void;

    constructor(debug?: (text: string) => void) {
        this._debug = debug;
    }

    print(text: string) {
        if (!this._debug) {
            return;
        }

        this._debug(text);
    }
}
